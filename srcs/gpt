IOEvent Route::setRessource(const t_http_message& req, Connexion* conn) const
{
    t_request_line reqLine = req.request_line;
    std::string completePath = attributes.root + reqLine.path;

    if (!attributes.redirect.empty())
    {
        conn->setRessource(new RedirectRessource(conn, attributes.redirect));
        return {};
    }

    int cgiIndex = isCGI(completePath);
    if (cgiIndex >= 0 && fileExists(extractBeforeChar(completePath, '?').c_str()))
    {
        std::string cgiExecutablePath = getCgiExecutablePath(cgiIndex);
        if (checkPermissions(completePath, S_IXUSR | S_IXGRP))
        {
            try
            {
                switch (reqLine.method)
                {
                    case GET:
                        conn->setRessource(new GetCGI(conn, cgiExecutablePath, completePath, extractAfterChar(completePath, '?')));
                        break;
                    case POST:
                        conn->setRessource(new PostCGI(conn, cgiExecutablePath, completePath));
                        break;
                    case DELETE:
                        conn->setRessource(new DeleteCGI(conn, cgiExecutablePath, completePath));
                        break;
                    default:
                        return conn->setError("", 405);
                }
                return {};
            }
            catch (const std::runtime_error& e)
            {
                return IOEvent(FAIL, conn, e.what(), 500);
            }
        }
        else
        {
            return conn->setError("", 403);
        }
    }

    if (fileExists(completePath.c_str()))
    {
        try
        {
            switch (reqLine.method)
            {
                case GET:
                    conn->setRessource(new GetStaticFile(conn, completePath));
                    break;
                case POST:
                    conn->setRessource(new PostStaticFile(conn, completePath));
                    break;
                case DELETE:
                    conn->setRessource(new DeleteStaticFile(conn, completePath));
                    break;
                default:
                    return conn->setError("", 405);
            }
            return {};
        }
        catch (const std::runtime_error& e)
        {
            return IOEvent(FAIL, conn, e.what(), 500);
        }
    }

    if (directoryExists(completePath.c_str()) && reqLine.method == GET)
    {
        if (fileExists((completePath + "index.html").c_str()))
        {
            if (checkPermissions(completePath + "index.html", R_OK))
            {
                try
                {
                    conn->setRessource(new GetStaticFile(conn, completePath + "index.html"));
                    return {};
                }
                catch (const std::runtime_error& e)
                {
                    return IOEvent(FAIL, conn, e.what(), 500);
                }
            }
        }
        else if (attributes.directory_listing && checkPermissions(completePath, X_OK))
        {
            try
            {
                conn->setRessource(new GetDirectory(conn, completePath));
                return {};
            }
            catch (const std::runtime_error& e)
            {
                return IOEvent(FAIL, conn, e.what(), 500);
            }
        }
    }

    return conn->setError("", 404);
}

std::string Route::getCgiExecutablePath(int index) const
{
    auto it = attributes.cgiMap.begin();
    std::advance(it, index);
    return it->second;
}